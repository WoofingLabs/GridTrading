<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GDOG: The first dog on GateLayer</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="https://www.woofswap.finance/image/tokens/gdog.png" type="image/x-icon">
    <style>
        :root {
            --primary-color: #ff9100;
            --secondary-color: #ff6f61;
            --gradient-bg: linear-gradient(180deg, #1e1e2f 0%, #2a2a3d 100%);
            --card-bg: #2c2f48;
            --input-bg: #373b5c;
            --text-color: #ffffff;
            --border-radius: 8px;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Poppins', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-color);
            padding: 10px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 90vw;
            min-width: 300px;
            background: var(--card-bg);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            border-radius: var(--border-radius);
            padding: 12px;
        }
        .header {
            background: linear-gradient(90deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            padding: 10px;
            border-radius: var(--border-radius);
            text-align: center;
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 12px;
        }
        .settings { margin: 8px 0; }
        .settings label {
            display: block;
            margin-bottom: 4px;
            font-weight: bold;
            color: var(--text-color);
            font-size: 0.9em;
        }
        .settings input, .settings textarea, .settings select {
            width: 100%;
            padding: 6px;
            background: var(--input-bg);
            border: none;
            border-radius: 6px;
            color: var(--text-color);
            font-size: 0.9em;
            margin-bottom: 8px;
        }
        .settings textarea { height: 80px; resize: vertical; }
        button {
            padding: 8px 16px;
            background: linear-gradient(90deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            color: var(--text-color);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            margin: 4px;
            transition: opacity 0.2s;
        }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button:hover:not(:disabled) { opacity: 0.9; }
        .balance-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            margin-bottom: 8px;
            color: var(--primary-color);
        }
        #status {
            margin-top: 8px;
            font-size: 0.85em;
            color: var(--primary-color);
            white-space: pre-wrap;
        }
        #log {
            height: 100px;
            overflow-y: scroll;
            border: 1px solid #ccc;
            padding: 6px;
            background: var(--input-bg);
            margin-top: 8px;
            border-radius: 6px;
            font-size: 0.85em;
            color: var(--text-color);
        }
        @media (max-width: 600px) {
            .container { padding: 8px; }
            .header { font-size: 1em; padding: 8px; }
            .settings label, .settings input, .settings select, .settings textarea, button, #status, #log {
                font-size: 0.8em;
            }
            button { padding: 6px 12px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">GDOG: The first dog on GateLayer</div>
        <div class="settings">
            <label>RPC URL: <input type="text" id="rpcUrl" value="https://gatelayer-mainnet.gatenode.cc"></label>
            <label>Chain ID: <input type="text" id="chainId" value="10088" readonly></label>
            <label>Gas Price (Gwei): <input type="number" id="gasPrice" value="0.5" step="0.1" min="0"></label>
            <label>Slippage (%): <input type="number" id="slippage" value="0.5" step="0.1" min="0"></label>
            <label>基准价格 (GT): <input type="number" id="basePrice" value="0.001" step="0.0001" min="0"></label>
            <label>价格区间 (%): <input type="number" id="priceRange" value="10" step="1" min="0"></label>
            <label>网格数量: <input type="number" id="gridCount" value="10" step="1" min="2"></label>
            <label>每网格金额 (GT): <input type="number" id="gridAmount" value="0.01" step="0.001" min="0"></label>
            <label>Private Keys (one per line, start with 0x): <textarea id="privateKeys" placeholder="0xkey1 (66 chars)\n0xkey2 (66 chars)"></textarea>
            <label>Token:
                <select id="tokenSelect">
                    <option value="0xf6d9cf57e20ba0d33372e8998a9424aa53411e04">GDOG</option>
                    <option value="0x614025d5b75a1e762111d4b845633728774d888a">MIMA</option>
                    <option value="0xd30d04405bbeb573ce4d8697fb4b3bcda6eb1777">GCAT (Blue)</option>
                    <option value="0xfb7a49bd483de0f2ed479f82a3f7f7f53e9e4057">GM</option>
                    <option value="0x01ec580a60dbf3c8f3e00805c5489037eff35675">GCAT (Black)</option>
                    <option value="0x8e0474a49163f1764d56a9fd9342b87f1d1aec00">LUCKY</option>
                    <option value="0x8b78ddf4c0908f3ddb23f27d8bd06b9daab8c7e2">TEST</option>
                </select>
            </label>
        </div>
        <button id="startButton">启动机器人</button>
        <button id="stopButton">停止机器人</button>
        <button id="checkBalanceButton">检查余额</button>
        <div class="balance-row"><span>GT 余额</span><span id="gtBalance">余额: 0</span></div>
        <div class="balance-row"><span>代币余额</span><span id="tokenBalance">余额: 0</span></div>
        <div id="status">状态: 就绪</div>
        <div id="log"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    <script>
        const GATE_ROUTER_ADDRESS = "0x12814690f59a9ce8ba87dc8cf0692442baa9c097";
        const WGT_ADDRESS = "0x6803b8e93b13941f6b73b82e324b80251b3de338";
        const TOKEN_ADDRESSES = {
            "GDOG": "0xf6d9cf57e20ba0d33372e8998a9424aa53411e04",
            "MIMA": "0x614025d5b75a1e762111d4b845633728774d888a",
            "GCAT (Blue)": "0xd30d04405bbeb573ce4d8697fb4b3bcda6eb1777",
            "GM": "0xfb7a49bd483de0f2ed479f82a3f7f7f53e9e4057",
            "GCAT (Black)": "0x01ec580a60dbf3c8f3e00805c5489037eff35675",
            "LUCKY": "0x8e0474a49163f1764d56a9fd9342b87f1d1aec00",
            "TEST": "0x8b78ddf4c0908f3ddb23f27d8bd06b9daab8c7e2"
        };

        const GATE_ROUTER_ABI = [
            {
                "inputs": [
                    { "internalType": "uint256", "name": "amountOutMin", "type": "uint256" },
                    { "internalType": "address[]", "name": "path", "type": "address[]" },
                    { "internalType": "address", "name": "to", "type": "address" },
                    { "internalType": "uint256", "name": "deadline", "type": "uint256" }
                ],
                "name": "swapExactETHForTokens",
                "outputs": [{ "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "uint256", "name": "amountIn", "type": "uint256" },
                    { "internalType": "address[]", "name": "path", "type": "address[]" }
                ],
                "name": "getAmountsOut",
                "outputs": [{ "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "uint256", "name": "amountIn", "type": "uint256" },
                    { "internalType": "uint256", "name": "amountOutMin", "type": "uint256" },
                    { "internalType": "address[]", "name": "path", "type": "address[]" },
                    { "internalType": "address", "name": "to", "type": "address" },
                    { "internalType": "uint256", "name": "deadline", "type": "uint256" }
                ],
                "name": "swapExactTokensForETH",
                "outputs": [{ "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        const ERC20_ABI = [
            {
                "constant": true,
                "inputs": [{ "name": "_owner", "type": "address" }],
                "name": "balanceOf",
                "outputs": [{ "name": "balance", "type": "uint256" }],
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    { "name": "_spender", "type": "address" },
                    { "name": "_value", "type": "uint256" }
                ],
                "name": "approve",
                "outputs": [{ "name": "success", "type": "bool" }],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [
                    { "name": "_owner", "type": "address" },
                    { "name": "_spender", "type": "address" }
                ],
                "name": "allowance",
                "outputs": [{ "name": "remaining", "type": "uint256" }],
                "type": "function"
            }
        ];

        const messages = {
            statusReady: "状态: 就绪",
            testingRPC: "正在测试 RPC 连接...",
            connectedToChain: "已连接到链 ID: ",
            expectedChain: " (Gate Layer 应为 10088)",
            chainMismatch: "错误: 未连接到 Gate Layer (链 ID 应为 10088)",
            rpcError: "错误: 无法连接到 RPC: ",
            noPrivateKeys: "错误: 未提供私钥",
            invalidTokenAddress: "错误: 无效的代币地址",
            invalidGasPrice: "错误: 无效的 Gas Price",
            invalidGridParams: "错误: 无效的网格参数（基准价格、价格区间、网格数量需有效）",
            processingWallet: "处理钱包 ",
            gtBalance: "GT 余额: ",
            tokenBalance: "代币余额: ",
            approvingToken: "正在为钱包授权代币 ",
            alreadyApproved: "代币已授权给钱包 ",
            buyingToken: "正在为钱包购买代币 ",
            sellingToken: "正在为钱包卖出代币 ",
            tradeSuccess: "交易成功！交易哈希: ",
            errorProcessing: "处理钱包时出错 ",
            errorMessage: ": ",
            allProcessed: "所有钱包处理完成",
            buttonProcessing: "处理中..."
        };

        function getMessage(key) {
            return messages[key] || key;
        }

        let web3Instance = null;
        let botRunning = false;
        let autoBuyInterval = null;
        let wallets = [];
        let currentWalletIndex = 0;
        let selectedToken = "0xf6d9cf57e20ba0d33372e8998a9424aa53411e04";
        let tokenSymbol = "GDOG";

        function log(message) {
            const logDiv = document.getElementById("log");
            if (!logDiv._pendingLog) {
                logDiv._pendingLog = [];
                setTimeout(() => {
                    logDiv.innerHTML += logDiv._pendingLog.map(msg => `<p>${new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}: ${msg}</p>`).join('');
                    logDiv.scrollTop = logDiv.scrollHeight;
                    logDiv._pendingLog = null;
                }, 50);
            }
            logDiv._pendingLog.push(message);
        }

        async function initializeWeb3() {
            const rpcUrl = document.getElementById("rpcUrl").value.trim();
            const status = document.getElementById("status");
            try {
                const provider = new Web3.providers.HttpProvider(rpcUrl, { timeout: 10000 });
                const web3 = new Web3(provider);
                status.textContent += getMessage("testingRPC") + "\n";
                log(getMessage("testingRPC"));
                const networkChainId = await web3.eth.getChainId();
                status.textContent += getMessage("connectedToChain") + networkChainId + getMessage("expectedChain") + "\n";
                log(getMessage("connectedToChain") + networkChainId + getMessage("expectedChain"));
                if (networkChainId !== 10088) {
                    status.textContent += getMessage("chainMismatch") + "\n";
                    status.textContent += "请尝试其他 RPC URL，如 https://gatelayer-rpc.gatenode.cc 或 https://rpc.gatelayer.org\n";
                    log(getMessage("chainMismatch"));
                    return null;
                }
                return web3;
            } catch (error) {
                status.textContent += getMessage("rpcError") + error.message + "\n";
                status.textContent += "请尝试其他 RPC URL，如 https://gatelayer-rpc.gatenode.cc 或 https://rpc.gatelayer.org\n";
                log(getMessage("rpcError") + error.message);
                return null;
            }
        }

        async function waitForTransaction(txHash) {
            let receipt = null;
            const maxAttempts = 30;
            let attempts = 0;
            while (attempts < maxAttempts) {
                receipt = await web3Instance.eth.getTransactionReceipt(txHash);
                if (receipt) {
                    if (receipt.status) return receipt;
                    throw new Error(`交易 ${txHash} 失败`);
                }
                await new Promise(resolve => setTimeout(resolve, 2000));
                attempts++;
            }
            throw new Error(`交易 ${txHash} 未在 ${maxAttempts} 次尝试后确认`);
        }

        async function checkAndApproveToken(wallet, tokenAddress) {
            const tokenContract = new web3Instance.eth.Contract(ERC20_ABI, tokenAddress);
            const gasPrice = web3Instance.utils.toWei(document.getElementById("gasPrice").value, "gwei");
            try {
                const allowance = await tokenContract.methods.allowance(wallet.address, GATE_ROUTER_ADDRESS).call();
                if (web3Instance.utils.toBN(allowance).gte(web3Instance.utils.toBN(2).pow(web3Instance.utils.toBN(256)).div(web3Instance.utils.toBN(2)))) {
                    log(getMessage("alreadyApproved") + wallet.address);
                    return true;
                }
                log(getMessage("approvingToken") + wallet.address + "...");
                const tx = await tokenContract.methods.approve(GATE_ROUTER_ADDRESS, web3Instance.utils.toBN(2).pow(web3Instance.utils.toBN(256)).sub(web3Instance.utils.toBN(1))).send({
                    from: wallet.address,
                    gas: 100000,
                    gasPrice
                });
                await waitForTransaction(tx.transactionHash);
                log(getMessage("tradeSuccess") + "授权成功: " + wallet.address);
                return true;
            } catch (error) {
                log(getMessage("errorProcessing") + wallet.address + getMessage("errorMessage") + "代币授权失败: " + error.message);
                return false;
            }
        }

        async function checkBalances() {
            const startButton = document.getElementById("checkBalanceButton");
            startButton.disabled = true;
            startButton.textContent = getMessage("buttonProcessing");
            const status = document.getElementById("status");
            status.textContent = getMessage("statusReady") + "\n";
            if (!web3Instance) {
                web3Instance = await initializeWeb3();
                if (!web3Instance) {
                    startButton.disabled = false;
                    startButton.textContent = "检查余额";
                    return;
                }
            }
            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);
            if (privateKeys.length < 1) {
                status.textContent += getMessage("noPrivateKeys") + "\n";
                log(getMessage("noPrivateKeys"));
                startButton.disabled = false;
                startButton.textContent = "检查余额";
                return;
            }
            const tokenSelect = document.getElementById("tokenSelect").value;
            const tokenContract = new web3Instance.eth.Contract(ERC20_ABI, tokenSelect);
            for (const pk of privateKeys) {
                try {
                    const account = web3Instance.eth.accounts.privateKeyToAccount(pk.trim());
                    const gtBalance = await web3Instance.eth.getBalance(account.address);
                    const tokenBalance = await tokenContract.methods.balanceOf(account.address).call();
                    status.textContent += getMessage("processingWallet") + account.address + "\n";
                    status.textContent += getMessage("gtBalance") + web3Instance.utils.fromWei(gtBalance, "ether") + " GT\n";
                    status.textContent += getMessage("tokenBalance") + web3Instance.utils.fromWei(tokenBalance, "ether") + ` ${tokenSymbol}\n`;
                    document.getElementById("gtBalance").textContent = `余额: ${web3Instance.utils.fromWei(gtBalance, "ether")} GT`;
                    document.getElementById("tokenBalance").textContent = `余额: ${web3Instance.utils.fromWei(tokenBalance, "ether")} ${tokenSymbol}`;
                    log(`${getMessage("processingWallet")}${account.address}: ${getMessage("gtBalance")}${web3Instance.utils.fromWei(gtBalance, "ether")} GT, ${getMessage("tokenBalance")}${web3Instance.utils.fromWei(tokenBalance, "ether")} ${tokenSymbol}`);
                } catch (error) {
                    status.textContent += getMessage("errorProcessing") + pk.slice(0, 10) + "..." + getMessage("errorMessage") + error.message + "\n";
                    log(getMessage("errorProcessing") + pk.slice(0, 10) + "..." + getMessage("errorMessage") + error.message);
                }
            }
            status.textContent += getMessage("allProcessed") + "\n";
            log(getMessage("allProcessed"));
            startButton.disabled = false;
            startButton.textContent = "检查余额";
        }

        function calculateGrid() {
            const basePrice = parseFloat(document.getElementById("basePrice").value);
            const priceRange = parseFloat(document.getElementById("priceRange").value) / 100;
            const gridCount = parseInt(document.getElementById("gridCount").value);
            if (isNaN(basePrice) || basePrice <= 0 || isNaN(priceRange) || priceRange < 0 || isNaN(gridCount) || gridCount < 2) {
                log(getMessage("invalidGridParams"));
                return null;
            }
            const minPrice = basePrice * (1 - priceRange);
            const maxPrice = basePrice * (1 + priceRange);
            const interval = (maxPrice - minPrice) / (gridCount - 1);
            const grids = [];
            for (let i = 0; i < gridCount; i++) {
                const price = minPrice + interval * i;
                grids.push({
                    price: price.toFixed(6),
                    type: price < basePrice ? "buy" : price > basePrice ? "sell" : "neutral"
                });
            }
            return grids;
        }

        async function purchaseGateSwap(wallet, GTAmount) {
            try {
                web3Instance.eth.accounts.wallet.add(wallet.privateKey);
                const approved = await checkAndApproveToken(wallet, selectedToken);
                if (!approved) {
                    log(`GateSwap: 代币授权失败: ${wallet.address}`);
                    document.getElementById("status").textContent += `GateSwap: 代币授权失败\n`;
                    return false;
                }
                const routerContract = new web3Instance.eth.Contract(GATE_ROUTER_ABI, GATE_ROUTER_ADDRESS);
                const gasPrice = web3Instance.utils.toWei(document.getElementById("gasPrice").value, "gwei");
                const gasLimit = 400000;
                const GTAmountWei = web3Instance.utils.toWei(GTAmount.toString(), "ether");
                const path = [WGT_ADDRESS, selectedToken];
                const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
                const balance = await web3Instance.eth.getBalance(wallet.address);
                const balanceGT = web3Instance.utils.fromWei(balance, "ether");
                if (parseFloat(balanceGT) < parseFloat(GTAmount) + 0.01) {
                    log(`GateSwap: 余额不足 ${wallet.address}: ${balanceGT} GT`);
                    document.getElementById("status").textContent += `GateSwap: 余额不足: ${balanceGT} GT\n`;
                    return false;
                }
                let attempts = 0;
                const maxAttempts = 3;
                let nonce = await web3Instance.eth.getTransactionCount(wallet.address, "pending");
                while (attempts < maxAttempts) {
                    try {
                        const amounts = await routerContract.methods.getAmountsOut(GTAmountWei, path).call();
                        const tokenAmount = web3Instance.utils.fromWei(amounts[1], "ether");
                        const tokenAmountWei = web3Instance.utils.toWei(tokenAmount, "ether");
                        const slippagePercent = parseFloat(document.getElementById("slippage").value) / 100;
                        const tokenAmountMin = web3Instance.utils.toBN(tokenAmountWei).mul(web3Instance.utils.toBN(Math.floor((1 - slippagePercent) * 1000))).div(web3Instance.utils.toBN(1000));
                        const tx = await routerContract.methods.swapExactETHForTokens(tokenAmountMin, path, wallet.address, deadline).send({
                            from: wallet.address,
                            value: GTAmountWei,
                            gas: gasLimit,
                            gasPrice,
                            nonce
                        });
                        await waitForTransaction(tx.transactionHash);
                        const txLink = `https://www.gatescan.org/gatelayer/tx/${tx.transactionHash}`;
                        log(getMessage("tradeSuccess") + tx.transactionHash);
                        document.getElementById("status").textContent += `GateSwap 购买: ${GTAmount} GT -> ~${parseFloat(tokenAmount).toFixed(6)} ${tokenSymbol}, TX: ${txLink}\n`;
                        return true;
                    } catch (error) {
                        attempts++;
                        log(`GateSwap 购买失败 (尝试 ${attempts}/${maxAttempts}): ${error.message}`);
                        if (error.message.includes("replacement transaction underpriced") || error.message.includes("nonce too low")) {
                            nonce = await web3Instance.eth.getTransactionCount(wallet.address, "pending");
                        }
                        if (attempts === maxAttempts) {
                            log(`GateSwap 购买失败: ${wallet.address}: ${error.message}`);
                            document.getElementById("status").textContent += `GateSwap 购买失败: ${error.message}\n`;
                            return false;
                        }
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }
            } catch (error) {
                log(`GateSwap 错误: ${error.message}`);
                document.getElementById("status").textContent += `GateSwap 错误: ${error.message}\n`;
                return false;
            }
        }

        async function sellGateSwap(wallet, GTAmount) {
            try {
                web3Instance.eth.accounts.wallet.add(wallet.privateKey);
                const approved = await checkAndApproveToken(wallet, selectedToken);
                if (!approved) {
                    log(`GateSwap: 代币授权失败: ${wallet.address}`);
                    document.getElementById("status").textContent += `GateSwap: 代币授权失败\n`;
                    return false;
                }
                const routerContract = new web3Instance.eth.Contract(GATE_ROUTER_ABI, GATE_ROUTER_ADDRESS);
                const gasPrice = web3Instance.utils.toWei(document.getElementById("gasPrice").value, "gwei");
                const gasLimit = 400000;
                const tokenAmountWei = web3Instance.utils.toWei(GTAmount.toString(), "ether");
                const path = [selectedToken, WGT_ADDRESS];
                const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
                const tokenContract = new web3Instance.eth.Contract(ERC20_ABI, selectedToken);
                const tokenBalance = await tokenContract.methods.balanceOf(wallet.address).call();
                const tokenBalanceGT = web3Instance.utils.fromWei(tokenBalance, "ether");
                if (parseFloat(tokenBalanceGT) < parseFloat(GTAmount)) {
                    log(`GateSwap: 代币余额不足 ${wallet.address}: ${tokenBalanceGT} ${tokenSymbol}`);
                    document.getElementById("status").textContent += `GateSwap: 代币余额不足: ${tokenBalanceGT} ${tokenSymbol}\n`;
                    return false;
                }
                let attempts = 0;
                const maxAttempts = 3;
                let nonce = await web3Instance.eth.getTransactionCount(wallet.address, "pending");
                while (attempts < maxAttempts) {
                    try {
                        const amounts = await routerContract.methods.getAmountsOut(tokenAmountWei, path).call();
                        const GTAmountMin = web3Instance.utils.toBN(amounts[1]).mul(web3Instance.utils.toBN(Math.floor((1 - parseFloat(document.getElementById("slippage").value) / 100) * 1000))).div(web3Instance.utils.toBN(1000));
                        const tx = await routerContract.methods.swapExactTokensForETH(tokenAmountWei, GTAmountMin, path, wallet.address, deadline).send({
                            from: wallet.address,
                            gas: gasLimit,
                            gasPrice,
                            nonce
                        });
                        await waitForTransaction(tx.transactionHash);
                        const txLink = `https://www.gatescan.org/gatelayer/tx/${tx.transactionHash}`;
                        log(getMessage("tradeSuccess") + tx.transactionHash);
                        document.getElementById("status").textContent += `GateSwap 卖出: ${GTAmount} ${tokenSymbol} -> GT, TX: ${txLink}\n`;
                        return true;
                    } catch (error) {
                        attempts++;
                        log(`GateSwap 卖出失败 (尝试 ${attempts}/${maxAttempts}): ${error.message}`);
                        if (error.message.includes("replacement transaction underpriced") || error.message.includes("nonce too low")) {
                            nonce = await web3Instance.eth.getTransactionCount(wallet.address, "pending");
                        }
                        if (attempts === maxAttempts) {
                            log(`GateSwap 卖出失败: ${wallet.address}: ${error.message}`);
                            document.getElementById("status").textContent += `GateSwap 卖出失败: ${error.message}\n`;
                            return false;
                        }
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }
            } catch (error) {
                log(`GateSwap 卖出错误: ${error.message}`);
                document.getElementById("status").textContent += `GateSwap 卖出错误: ${error.message}\n`;
                return false;
            }
        }

        async function startBot() {
            const startButton = document.getElementById("startButton");
            startButton.disabled = true;
            startButton.textContent = getMessage("buttonProcessing");
            const status = document.getElementById("status");
            status.textContent = getMessage("statusReady") + "\n";
            if (botRunning) {
                log("错误: 机器人已在运行");
                status.textContent += "错误: 机器人已在运行\n";
                startButton.disabled = false;
                startButton.textContent = "启动机器人";
                return;
            }
            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);
            const tokenSelect = document.getElementById("tokenSelect").value;
            selectedToken = tokenSelect;
            tokenSymbol = Object.keys(TOKEN_ADDRESSES).find(key => TOKEN_ADDRESSES[key].toLowerCase() === tokenSelect.toLowerCase()) || "未知";
            const gasPrice = parseFloat(document.getElementById("gasPrice").value);
            const grids = calculateGrid();
            if (privateKeys.length < 1) {
                log(getMessage("noPrivateKeys"));
                status.textContent += getMessage("noPrivateKeys") + "\n";
                startButton.disabled = false;
                startButton.textContent = "启动机器人";
                return;
            }
            if (isNaN(gasPrice) || gasPrice <= 0) {
                log(getMessage("invalidGasPrice"));
                status.textContent += getMessage("invalidGasPrice") + "\n";
                startButton.disabled = false;
                startButton.textContent = "启动机器人";
                return;
            }
            if (!grids) {
                status.textContent += getMessage("invalidGridParams") + "\n";
                startButton.disabled = false;
                startButton.textContent = "启动机器人";
                return;
            }
            wallets = [];
            for (const pk of privateKeys) {
                try {
                    const account = web3Instance ? web3Instance.eth.accounts.privateKeyToAccount(pk.trim()) : { address: Web3.utils.privateToAddress(pk) };
                    log(`有效私钥: 地址 ${account.address}`);
                    wallets.push({ address: account.address, privateKey: pk.trim() });
                } catch (error) {
                    log(`无效私钥: ${pk.slice(0, 10)}...: ${error.message}`);
                }
            }
            if (wallets.length === 0) {
                log("错误: 未提供有效私钥");
                status.textContent += "错误: 未提供有效私钥\n";
                startButton.disabled = false;
                startButton.textContent = "启动机器人";
                return;
            }
            if (!web3Instance) {
                web3Instance = await initializeWeb3();
                if (!web3Instance) {
                    startButton.disabled = false;
                    startButton.textContent = "启动机器人";
                    return;
                }
            }
            botRunning = true;
            currentWalletIndex = 0;
            log(`加载 ${wallets.length} 个有效钱包`);
            log(`网格设置: ${grids.map(g => `${g.type === "buy" ? "买" : g.type === "sell" ? "卖" : "中立"}@${g.price} GT`).join(", ")}`);
            status.textContent += `加载 ${wallets.length} 个有效钱包\n`;
            autoBuyInterval = setInterval(async () => {
                if (!botRunning || !web3Instance) return;
                const wallet = wallets[currentWalletIndex];
                const routerContract = new web3Instance.eth.Contract(GATE_ROUTER_ABI, GATE_ROUTER_ADDRESS);
                const GTAmount = parseFloat(document.getElementById("gridAmount").value);
                const path = [WGT_ADDRESS, selectedToken];
                const amounts = await routerContract.methods.getAmountsOut(web3Instance.utils.toWei("1", "ether"), path).call();
                const currentPrice = web3Instance.utils.fromWei(amounts[1], "ether");
                log(`当前价格: ${currentPrice} GT`);
                for (const grid of grids) {
                    if (grid.type === "buy" && parseFloat(currentPrice) <= parseFloat(grid.price)) {
                        log(getMessage("buyingToken") + wallet.address + ` (${GTAmount} GT @ ${grid.price} GT)`);
                        await purchaseGateSwap(wallet, GTAmount);
                    } else if (grid.type === "sell" && parseFloat(currentPrice) >= parseFloat(grid.price)) {
                        log(getMessage("sellingToken") + wallet.address + ` (${GTAmount} ${tokenSymbol} @ ${grid.price} GT)`);
                        await sellGateSwap(wallet, GTAmount);
                    }
                }
                await checkBalances();
                currentWalletIndex = (currentWalletIndex + 1) % wallets.length;
            }, 10000);
            log(`网格交易启动: 每 10 秒检查 ${tokenSymbol} 价格`);
            status.textContent += `网格交易 ${tokenSymbol} 启动\n`;
            startButton.disabled = false;
            startButton.textContent = "启动机器人";
        }

        function stopBot() {
            const stopButton = document.getElementById("stopButton");
            stopButton.disabled = true;
            stopButton.textContent = getMessage("buttonProcessing");
            if (autoBuyInterval) {
                clearInterval(autoBuyInterval);
                autoBuyInterval = null;
            }
            botRunning = false;
            log("机器人已停止");
            document.getElementById("status").textContent = "状态: 机器人已停止\n";
            stopButton.disabled = false;
            stopButton.textContent = "停止机器人";
        }

        document.addEventListener("DOMContentLoaded", () => {
            log("页面加载完成，准备启动机器人");
            document.getElementById("tokenSelect").addEventListener("change", () => {
                selectedToken = document.getElementById("tokenSelect").value;
                tokenSymbol = Object.keys(TOKEN_ADDRESSES).find(key => TOKEN_ADDRESSES[key].toLowerCase() === selectedToken.toLowerCase()) || "未知";
            });
            document.getElementById("startButton").addEventListener("click", startBot);
            document.getElementById("stopButton").addEventListener("click", stopBot);
            document.getElementById("checkBalanceButton").addEventListener("click", checkBalances);
        });
    </script>
</body>
</html>
